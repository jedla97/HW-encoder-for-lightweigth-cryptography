#include "generation.h"
#include "xparameters.h"
#include "xil_io.h"
#include "xil_types.h"
#include "xil_assert.h"
#include "xgpiops_hw.h"
#include "xgpio.h"
#include "sdcard_operations.h"
#include "xtime_l.h"
#include "xuartps.h"

int main() {
	XTime tStart, tEnd;

	int status = 0;

	XGpio input, output;
	int button_data = 0;
	xil_printf("start\n");
	// Initialize gpio for buttons
	XGpio_Initialize(&input, XPAR_AXI_GPIO_0_DEVICE_ID);
	// Initialize gpio for RGB LED
	XGpio_Initialize(&output, XPAR_AXI_GPIO_2_DEVICE_ID);
	// set default values
	XGpio_SetDataDirection(&output, 1, 0xffffffff);
	XGpio_SetDataDirection(&input, 1, 0xffffffff);

	// waiting for pressing button in infinite cycle
	while (1) {
		// read what was pressed
		button_data = XGpio_DiscreteRead(&input, 1);

		// when nothing is pressed
		if (button_data == 0b0000) {

		}
		// button BTN0
		else if (button_data == 0b0001) {
			//xil_printf("button 0\n");
			XUartPs_Config *Config;
			XUartPs Uart_PS;
			u8 *buffer;
			u8 *bufferTest;
			u32 Status;
			u32 recBites = 0;
			u32 sendBites = 0;
			u32 totalrec = 0;
			u32 totalsend = 0;
			int end_status = 0;
			button_data = 0;

			buffer = malloc(sizeof(u8));
			bufferTest = malloc(sizeof(u8));
			bufferTest[0] = 'a';
			xil_printf("%08X", bufferTest[0]);

			// UART 0 initialization

			Config = XUartPs_LookupConfig(XPAR_XUARTPS_0_DEVICE_ID);
			if (NULL == Config) {
				return XST_FAILURE;
			}
			Status = XUartPs_CfgInitialize(&Uart_PS, Config,
					Config->BaseAddress);
			if (Status != XST_SUCCESS) {
				return XST_FAILURE;
			}
			Status = XUartPs_SetBaudRate(&Uart_PS, 115200);
			if (Status != XST_SUCCESS) {
				return XST_FAILURE;
			}
			sleep(1);
			while (end_status == 0) {
				while (totalrec < 1 && end_status == 0) {
					recBites = XUartPs_Recv(&Uart_PS, (u8*) &buffer[totalrec],
							1);
					totalrec += recBites;
					button_data = XGpio_DiscreteRead(&input, 1);
					if (button_data == 0b0001) {
						end_status = 1;
					}

				}
				totalrec = 0;
				if (end_status == 1) {
					while (totalsend < 1) {
						sendBites = XUartPs_Send(&Uart_PS, (u8*) &bufferTest[0],
								1);
						totalsend += sendBites;
					}
					break;
				} else {
					while (totalsend < 1) {
						sendBites = XUartPs_Send(&Uart_PS,
								(u8*) &buffer[totalsend], 1);
						totalsend += sendBites;
					}
					totalsend = 0;
				}

			}
			free(buffer);
			free(bufferTest);

		}
		// button BTN1
		else if (button_data == 0b0010) {
			XGpio_DiscreteWrite(&output, 1, 0x00);
			xil_printf("button 1\n");
			XTime_GetTime(&tStart);
			status = mount_drive();
			if (status == 0) {
				status = cipher_text_OFB();
				if (status == 0) {
					status = unmount_drive();
				} else {
					unmount_drive();
				}

			}
			if (status == 0) {
				//green
				XGpio_DiscreteWrite(&output, 1, 0x10);
			} else {
				//red
				XGpio_DiscreteWrite(&output, 1, 0x20);
			}
			XTime_GetTime(&tEnd);
			printf("Output took %llu clock cycles.\n", 2 * (tEnd - tStart));
			printf("Output took %.2f us.\n",
					1.0 * (tEnd - tStart) / (COUNTS_PER_SECOND / 1000000));

		}

// sd card cipher with generated key ;; button BTN2
		else if (button_data == 0b0100) {
			xil_printf("button 2\n");
			XGpio_DiscreteWrite(&output, 1, 0x00);
			status = mount_drive();
			if (status == 0) {
				status = save_and_generate_key();
				if (status == 0) {
					status = cipher_text_CFB_32bit();
					if (status == 0) {
						status = unmount_drive();
					} else {
						unmount_drive();
					}
				} else {
					unmount_drive();
				}

			}
			if (status == 0) {
				//green
				XGpio_DiscreteWrite(&output, 1, 0x10);
			} else {
				//red
				XGpio_DiscreteWrite(&output, 1, 0x20);
			}

		}
// sd card cipher with predefined key ;; button BTN3
		else if (button_data == 0b1000) {
			XGpio_DiscreteWrite(&output, 1, 0x00);
			xil_printf("button 3\n");
			XTime_GetTime(&tStart);
			status = mount_drive();
			if (status == 0) {
				status = cipher_text_CFB_32bit();
				if (status == 0) {
					status = unmount_drive();
				} else {
					unmount_drive();
				}

			}
			if (status == 0) {
				//green
				XGpio_DiscreteWrite(&output, 1, 0x10);
			} else {
				//red
				XGpio_DiscreteWrite(&output, 1, 0x20);
			}
			XTime_GetTime(&tEnd);
			printf("Output took %llu clock cycles.\n", 2 * (tEnd - tStart));
			printf("Output took %.2f us.\n",
					1.0 * (tEnd - tStart) / (COUNTS_PER_SECOND / 1000000));
		} else {
			xil_printf("%X\n", button_data);
		}
	}

//XPAR_LBLOCK_WRAPPER_0_S00_AXI_BASEADDR 0x43C00000

	return 0;
}
